package ru.lcard.ltr.ltr25;

import jnr.ffi.LibraryLoader;
import jnr.ffi.annotations.Out;
import jnr.ffi.byref.IntByReference;
import ru.lcard.ltr.BooleanByReference;

public interface Ltr25Api {

    Ltr25Api INSTANCE = LibraryLoader.create(Ltr25Api.class).load("ltr25api");

    /**
     * Количество каналов АЦП в одном модуле LTR25
     */
    int LTR25_CHANNEL_CNT = 8;

    /**
     * Количество частот дискретизации.
     */
    int LTR25_FREQ_CNT = 8;

    /**
     * Количество частот, для которых сохраняются калибровочные коэффициенты
     */
    int LTR25_CBR_FREQ_CNT = 2;

    /**
     * Количество значений источника тока
     */
    int LTR25_I_SRC_VALUE_CNT = 2;

    /**
     * Размер поля с названием модуля.
     */
    int LTR25_NAME_SIZE = 8;

    /**
     * Размер поля с серийным номером модуля.
     */
    int LTR25_SERIAL_SIZE = 16;

    /**
     * Максимальное пиковое значение в Вольтах для диапазона измерения модуля
     */
    int LTR25_ADC_RANGE_PEAK = 10;

    /**
     * Код АЦП, соответствующее максимальному пиковому значению
     */
    int LTR25_ADC_SCALE_CODE_MAX = 2000000000;

    /**
     * Адрес, с которого начинается пользовательская область flash-памяти
     */
    int LTR25_FLASH_USERDATA_ADDR = 0x0;

    /**
     * Размер пользовательской области flash-памяти
     */
    int LTR25_FLASH_USERDATA_SIZE = 0x100000;
    /**
     * Минимальный размер блока для стирания flash-памяти. Все операции стирания
     * должны быть кратны данному размеру
     */
    int LTR25_FLASH_ERASE_BLOCK_SIZE = 4096;

    /**
     * Размер серийного номера узла  TEDS в байтах
     */
    int LTR25_TEDS_NODE_SERIAL_SIZE = 6;


    /**
     * Инициализация описателя модуля.
     * <p>
     * Функция инициализирует поля структуры описателя модуля значениями по умолчанию.
     * Эта функция должна вызываться для каждой структуры #TLTR25 перед вызовом
     * остальных функций.
     */
    int LTR25_Init(TLTR25 hnd);

    /**
     * Открытие соединения с модулем.
     * <p>
     * Функция устанавливает соединение с модулем в соответствии с переданными
     * параметрами, проверяет наличие модуля и считывает информацию о нем.
     * Должна быть вызвана перед работой с модулем. После завершения работы
     * необходимо закрыть соединение с помощью LTR25_Close().
     *
     * @param ltrd_addr
     * @param ltrd_port
     * @param slot
     * @return
     */
    int LTR25_Open(TLTR25 hnd, int ltrd_addr, int ltrd_port, String csn, int slot);

    int LTR25_OpenEx(TLTR25 hnd, int ltrd_addr, int ltrd_port, String csn, int slot, int in_flags, IntByReference out_flags);

    /**
     * Закрытие соединения с модулем.
     * <p>
     * Функция закрывает ранее открытое с помощью LTR25_Open() соединение. Должна
     * вызываться после завершения работы с модулем. При любом возвращенном значении
     * после вызова этой функции соответствующий описатель уже нельзя использовать
     * для работы с модулем без открытия нового соединения.
     *
     * @return
     */
    int LTR25_Close(TLTR25 hnd);

    /**
     * Проверка, открыто ли соединение с модулем.
     * <p>
     * Функция проверяет, открыто ли в данный момент соединение с модулем. Если
     * соединение открыто, функция возвращает LTR_OK, если закрыто --- код ошибки
     * LTR_ERROR_CHANNEL_CLOSED.
     *
     * @return
     */
    int LTR25_IsOpened(TLTR25 hnd);

    /**
     * Запись настроек в модуль.
     * <p>
     * Функция передает настройки, соответствующие значением полей поля
     *
     * @return
     * @structref{TLTR25,Cfg} описателя модуля, в модуль.
     * Должна вызываться перед первым запуском сбора данных с помощью
     * LTR25_Start().
     */
    int LTR25_SetADC(TLTR25 hnd);


    /**
     * Запуск сбора данных.
     * <p>
     * При вызове данной функции запускается сбор данных с АЦП модуля. После успешного
     * завершения этой функции запускается АЦП и модуль начинает передавать в ПК
     * полученные отсчеты, которые необходимо вычитывать с помощью LTR25_Recv().
     * При завершении измерения для остановки сбора данных необходимо вызвать
     * LTR25_Stop().
     * <p>
     * Хотя бы один из каналов АЦП должен быть до этого разрешен и модуль должен быть
     * хотя бы раз сконфигурирован с помощью LTR25_SetADC().
     *
     * @return
     */
    int LTR25_Start(TLTR25 hnd);

    /**
     * Останов сбора данных.
     * <p>
     * При вызове данной функции модуль останавливает сбор и выдачу данных АЦП.
     * <p>
     * При этом вычитываются и выбрасываются все переданные, но непрочитанные
     * данные от модуля.
     *
     * @param hnd
     * @return
     */
    int LTR25_Stop(TLTR25 hnd);

    /**
     * Прием данных от модуля.
     * <p>
     * Функция принимает запрашиваемое число слов от модуля. Возвращаемые слова
     * находятся в специальном формате, который включает в себя служебную информацию.
     * Формат и количество слов на один отсчет определяется настройкой
     *
     * @param hnd
     * @param size
     * @param timeout
     * @return
     * @structref{TLTR25_CONFIG,DataFmt}. Для обработки принятых слов и получения значений АЦП используется функция
     * LTR25_ProcessData().
     * <p>
     * Функция возвращает управление либо когда примет запрошенное количество слов,
     * либо по истечению таймаута. При этом реально принятое количество слов можно
     * узнать по возвращенному значению.
     */
    int LTR25_Recv(TLTR25 hnd, int[] data, int[] tmark, int size, int timeout);


    /**
     * Обработка принятых от модуля слов.
     * <p>
     * Функция используется для обработки слов, принятых от модуля с помощью LTR25_Recv().
     * Функция проверяет служебные поля принятых слов, извлекает полезную информацию
     * с отсчетами и, при указании флага #LTR25_PROC_FLAG_VOLT, переводит отсчеты в
     * Вольты.
     * <p>
     * Функция предполагает, что передаваемые слова выровнены на начало кадра (первое
     * слово первого разрешенного канала). Если это не так, то неполный кадр в начале
     * будет отброшен и функция вернет ошибку LTR_ERROR_PROCDATA_UNALIGNED.
     * <p>
     * Также функция анализирует признаки обрыва или КЗ в разрешенных каналах. При
     * наличии подобного признака для хотя бы одного отсчета соответствующего
     * канала устанавливается соответствующей статус в элементе массива ch_status.
     * <p>
     * В отличие от модуля LTR25 в модуле LTR25 калибровка отсчетов и корректировка
     * АЧХ выполняется внутри модуля аппаратно, поэтому в LTR25_ProcessData() нет
     * подобных флагов.
     * <p>
     * По умолчанию функция предполагает, что все принятые данные обрабатываются
     * и только один раз, проверяя непрерывность счетчика и между вызовами функции,
     * а также сохраняя состояния фильтров между вызывами.
     * Если это условие не выполняется, то нужно передать флаг #LTR25_PROC_FLAG_NONCONT_DATA.
     *
     * @param hnd
     * @param flags
     * @return
     */
    int LTR25_ProcessData(TLTR25 hnd, int[] src, double[] dest, IntByReference size, int flags, IntByReference ch_status);


    /**
     * Поиск начала первого кадра.
     * <p>
     * Функция находит в принятом массиве сырых данных от модуля индекс первого
     * слова первого начала кадра. Может использоваться для выравнивания на
     * начало кадра данных в случае произошедшего сбоя без останова сбора.
     * <p>
     * Если в переданном массиве начало кадра не найдено, то функция вернет ошибку
     * LTR_ERROR_FIRSTFRAME_NOTFOUND.
     *
     * @param hnd
     * @param size
     * @return
     */
    int LTR25_SearchFirstFrame(TLTR25 hnd, int[] data, int size, IntByReference index);

    /**
     * Получение сообщения об ошибке.
     * <p>
     * Функция возвращает строку, соответствующую переданному коду ошибки, в кодировке
     * CP1251 для ОС Windows или UTF-8 для ОС Linux. Функция может обработать как ошибки
     * из ltr25api, так и общие коды ошибок из ltrapi.
     *
     * @param err
     * @return
     */
    String LTR25_GetErrorString(int err);


    /**
     * Чтение информации и калибровочных коэффициентов.
     * <p>
     * Функция считывает информацию из flash-памяти модуля и обновляет поля
     *
     * @param hnd
     * @return
     * @structref{TLTR25,ModuleInfo} в управляющей структуре модуля.
     * Так как данная операция уже выполняется при вызове LTR25_Open(),
     * то как правило вызов данной функции не требуется.
     * Однако данная функция может быть использована для восстановления измененных
     * коэффициентов в ModuleInfo на заводские.
     */
    int LTR25_GetConfig(TLTR25 hnd);

    int LTR25_StoreConfig(TLTR25 hnd, /*TLTR_CARD_START_MODE*/int start_mode);


    /**
     * Перевод модуля в режим низкого потребления.
     * <p>
     * Функция переводит модуль в режим низкого потребления или переводит его
     * из этого режима снова в рабочий. В режиме низкого потребления
     * снято питание с АЦП и источники тока установлены 2.86 мА. Доступ
     * к регистрам АЦП невозможен. Этот режим может быть использован для полного
     * сброса АЦП, для чего в этом режиме модуль должен находится не менее 5 с.
     *
     * @param hnd
     * @param lowPowMode
     * @return
     */
    int LTR25_SetLowPowMode(TLTR25 hnd, Boolean lowPowMode);

    /**
     * Проверка, разрешена ли работа ПЛИС модуля.
     * <p>
     * Функция проверяет, разрешена ли работа ПЛИС модуля. Для настройки и сбора
     * данных ПЛИС должен быть всегда разрешен.
     *
     * @param hnd
     * @return
     */
    int LTR25_FPGAIsEnabled(TLTR25 hnd, BooleanByReference enabled);

    /**
     * Разрешение работы ПЛИС модуля.
     * <p>
     * Функция разрешает или запрещает работу ПЛИС модуля. Для настройки и сбора
     * данных ПЛИС должен быть всегда разрешен. В LTR25_Open() выполняется разрешение
     * работы ПЛИС, если была найдена прошивка ПЛИС в памяти модуля и она была
     * успешно загружена, поэтому в штатной работе данная функция не используется.
     *
     * @param hnd
     * @param enable
     * @return
     */
    int LTR25_FPGAEnable(TLTR25 hnd, Boolean enable);


    /**
     * Чтение данных из flash-памяти модуля
     * <p>
     * Функция вычитывает данные, записанные во flash-памяти модуля по заданному
     * адресу. Пользователю выделяется область памяти с адреса
     * #LTR25_FLASH_USERDATA_ADDR размером #LTR25_FLASH_USERDATA_SIZE байт.
     *
     * @param hnd
     * @param addr
     * @param size
     * @return
     */
    int LTR25_FlashRead(TLTR25 hnd, int addr, byte[] data, int size);

    /**
     * Запись данных во flash-память модуля
     * <p>
     * Функция записывает данные во flash-память модуля по заданному
     * адресу. Записываемая область должна быть предварительно стерта с помощью
     * LTR25_FlashErase(). Пользователю выделяется область памяти с адреса
     * #LTR25_FLASH_USERDATA_ADDR размером #LTR25_FLASH_USERDATA_SIZE байт.
     *
     * @param hnd
     * @param addr
     * @param size
     * @return
     */
    int LTR25_FlashWrite(TLTR25 hnd, int addr, byte[] data, int size);

    /**
     * Стирание области flash-память модуля
     * <p>
     * Функция стирает область во flash-памяти модуля по заданному
     * адресу. Стирание необходимо выполнять перед записью данных.
     * Стирание возможно только блоками, кратными #LTR25_FLASH_ERASE_BLOCK_SIZE байт.
     * Пользователю выделяется область памяти с адреса
     * #LTR25_FLASH_USERDATA_ADDR размером #LTR25_FLASH_USERDATA_SIZE байт.
     *
     * @param hnd
     * @param addr
     * @param size
     * @return
     */
    int LTR25_FlashErase(TLTR25 hnd, int addr, int size);

    /**
     * Проверка поддержки модуля работы с TEDS
     * <p>
     * Данная функция служит для проверки, поддерживает ли данный
     * экземпляр модуля LTR25 работу с TEDS-датчиками в цифровом режиме, что
     * определяет возможность использования остальных функций из данной главы.
     * <p>
     * Если поддерживает, то функция возвращает LTR_OK, иначе --- код ошибки.
     **/
    int LTR25_CheckSupportTEDS(TLTR25 hnd);

    /**
     * Установка режима питания датчиков
     * <p>
     * Функция устанавливает режим питания датчиков для всех каналов модуля.
     * Основным рабочим режимом является #LTR25_SENSORS_POWER_MODE_ICP (единственный
     * доступный для ревизии модуля 0 или 1).
     * <p>
     * Для доступа к энергонезависимой памяти TEDS-датчиков (или другим функциям узлов TEDS)
     * необходимо сперва  установить режим #LTR25_SENSORS_POWER_MODE_TEDS, в котором
     * на датчики подается питание противоположной полярности.
     */
    int LTR25_SetSensorsPowerMode(TLTR25 hnd, int mode);

    /**
     * Обнаружение узла TEDS
     * <p>
     * Функция выполняет определение наличия устройства (как правило памяти),
     * реализующего узел TEDS, подключенного к указанному каналу модуля LTR25.
     * <p>
     * Функция также считывает  64-битный URN (уникальный регистрационный номер)
     * устройства, содержащий код семейства, которому принадлежит устройство,
     * серийный номер и CRC.
     * <p>
     * При успешном считывании и проверке CRC функция анализирует считанный код
     * семейства устройств, и, если он принадлежит одному из поддерживаемых устройств,
     * определяет по этому коду основные параметры устройства.
     * <p>
     * Считанная и полученная по коду семейства информация, описывающая устройство,
     * возвращается в виде структуры #TLTR25_TEDS_NODE_INFO.
     * <p>
     * Список поддерживаемых библиотекой семейств устройств определен в перечислении
     * #e_LTR25_TEDS_NODE_FAMILY_CODE.
     * <p>
     * Если устройство обнаружено успешно, но тип не поддерживается библиотекой,
     * то функция вернет ошибку #LTR25_ERR_TEDS_UNSUP_NODE_FAMILY, но считанная
     * часть информации о устройстве будет возвращена (идентификатор и серийный номер).
     * Действительность возвращенной информации о памяти можно проверить по полю
     * [Valid](@ref TLTR25_TEDS_NODE_INFO::Valid).
     * <p>
     * Для данной функции предварительно должен быть установлен режим
     * питания датчиков #LTR25_SENSORS_POWER_MODE_TEDS.
     */
    int LTR25_TEDSNodeDetect(TLTR25 hnd, int ch, @Out TLTR25_TEDS_NODE_INFO devinfo);

    /**
     * Чтение TEDS данных из энергонезависимой памяти датчика
     * <p>
     * Функция выполняет чтение данных TEDS из энергонезависимой памяти узла TEDS.
     * <p>
     * Функция выполняет чтение всех данных последовательно, как они хранятся в памяти
     * в нужном порядке, проверяя и удаляя байты с контрольной суммой.
     * <p>
     * Предварительно должен быть установлен режим питания датчиков #LTR25_SENSORS_POWER_MODE_TEDS.
     */
    int LTR25_TEDSReadData(TLTR25 hnd, int ch, byte[] data, int size, IntByReference read_size);

}
